ğŸ§  1ï¸âƒ£ What Is vlib_buffer_t?

In FD.io VPP, packets are not passed directly between nodes.

Instead:

Each packet lives inside a vlib_buffer_t.

So:

Frame â†’ buffer index â†’ vlib_buffer_t â†’ packet bytes

ğŸ”· 2ï¸âƒ£ What Is Inside vlib_buffer_t?

Letâ€™s simplify the structure.

typedef struct {
    u32 flags;
    u32 current_data;
    u32 current_length;
    u32 total_length_not_including_first_buffer;
    u32 next_buffer;
    u32 error;
    u32 sw_if_index[2];
    u32 feature_arc_index;
    u32 flow_id;
    // ... more fields
    u8  data[0];  // actual packet data starts here
} vlib_buffer_t;

Now letâ€™s explain each important part.

ğŸ”¹ 3ï¸âƒ£ Important Buffer Fields (Simple Explanation)
âœ… 1. flags

Stores packet state.

Example:

Is it IP packet?

Is it traced?

Is it chained?

Is checksum verified?

This helps nodes know how to treat the packet.

âœ… 2. current_data

This is VERY important.

It tells:

Where does the packet currently start?

Example:

Packet in memory:

[Ethernet][IP][TCP][Payload]

If we are in ip4-input node:

We move pointer forward:

current_data â†’ start of IP header

So nodes don't copy data.
They just move pointer inside buffer.

This is very efficient.

âœ… 3. current_length

Length of current buffer segment.

âœ… 4. total_length_not_including_first_buffer

Used when packet is split across multiple buffers.

Example:
Large packet (Jumbo frame).

âœ… 5. next_buffer

If packet spans multiple buffers:

Buffer A â†’ Buffer B â†’ Buffer C

This field links them.

âœ… 6. error

Stores error code if packet is dropped.

Example:

TTL expired

No route

Checksum failed

âœ… 7. sw_if_index[2]

Stores:

sw_if_index[RX]
sw_if_index[TX]

This tells:

Which interface packet came from

Which interface it will go to

âœ… 8. feature_arc_index

Used for VPP feature pipeline.

Example:

ACL

NAT

IPsec

âœ… 9. data[]

This is actual packet memory.

Important:

vlib_buffer_t metadata comes first
Packet bytes come after metadata

ğŸ”¥ 4ï¸âƒ£ Memory Layout

Think of memory like this:

---------------------------------
| vlib_buffer_t metadata        |
---------------------------------
| packet bytes                  |
---------------------------------

No separate allocation.

Everything in one block.

This improves cache locality.

ğŸ§  5ï¸âƒ£ How VPP Uses Buffer

Inside node:

vlib_buffer_t *b = vlib_get_buffer(vm, buffer_index);

Then:

u8 *pkt = vlib_buffer_get_current(b);

Now you can read packet headers.

ğŸš€ 6ï¸âƒ£ Now Compare With DPDK rte_mbuf

From DPDK

DPDK uses:

struct rte_mbuf
ğŸ” What Is Inside rte_mbuf?

Simplified:

struct rte_mbuf {
    void *buf_addr;
    uint16_t data_off;
    uint16_t data_len;
    uint32_t pkt_len;
    uint64_t ol_flags;
    struct rte_mbuf *next;
};
ğŸ§  7ï¸âƒ£ Key Differences
Feature	vlib_buffer_t	rte_mbuf
Designed for	Graph processing	Poll loop processing
Contains feature arc info	âœ… Yes	âŒ No
Stores interface indexes	âœ… Yes	âŒ No
Error tracking built-in	âœ… Yes	Limited
Graph next handling	Integrated	Not aware
Metadata size	Larger	Smaller
Scheduling integration	Yes	No
Used outside VPP	No	Yes
ğŸ”¥ Deep Design Difference
DPDK philosophy:
Application controls everything
mbuf is simple
You build pipeline manually
VPP philosophy:
Graph controls flow
Buffer carries rich metadata
Scheduler handles execution

So VPP buffer contains more networking intelligence.

âš¡ Performance Design Difference
DPDK:

Very lightweight

Application decides everything

Good for custom pipelines

VPP:

Slightly heavier metadata

Much smarter packet context

Integrated graph processing

ğŸ§¬ 8ï¸âƒ£ What Happens When Using DPDK Inside VPP?

When VPP uses DPDK plugin:

rte_mbuf â†’ converted into vlib_buffer_t

VPP copies or attaches metadata so that graph can use it.

After that, VPP works only with vlib_buffer_t.

ğŸ¯ 9ï¸âƒ£ Why VPP Buffer Is More Complex

Because it must support:

L2 switching

L3 routing

NAT

IPsec

ACL

Multi-feature pipeline

Multi-thread scheduling

Graph dispatch

Error counters

Trace system

All of that requires metadata.

ğŸ§  Final Mental Model
DPDK rte_mbuf

Think of it like:

ğŸ“¦ Basic packet container

VPP vlib_buffer_t

Think of it like:

ğŸ“¦ Packet container
â• Routing info
â• Interface info
â• Error info
â• Feature info
â• Graph execution info

ğŸ”¥ Important Concept to Remember

VPP does NOT just forward packets.

It builds a programmable graph router.

So buffers must carry context across nodes.

ğŸ Clean Summary

vlib_buffer_t:

Contains metadata + packet data

Used inside VPP graph

Carries routing and feature state

Integrated with scheduler

rte_mbuf:

Simpler

Used in DPDK poll loop

No graph awareness

No feature pipeline awareness

If you want next deep level ğŸ”¥ I can explain:

How buffer pool is allocated

How buffers are recycled

How chaining works internally

How zero-copy works

How prefetching works in buffer access

Or draw a cycle-by-cycle packet journey inside buffer

Tell me which one you want next.

âœ… 9. `data[]` ------------- This is actual packet memory. Important: `vlib_buffer_t` metadata comes first Packet bytes come after metadata

can u vistualize the vlib_buffer_t with that parameters like each index stores what

Perfect ğŸ‘Œ letâ€™s visually build vlib_buffer_t in memory so you can clearly see:

Where metadata lives

Where packet bytes live

What each field controls

How current_data moves

Weâ€™ll visualize it like a real memory layout.

ğŸ§  Big Picture: How vlib_buffer_t Looks in Memory

In FD.io VPP, a buffer is allocated as:

-----------------------------------------
| Metadata (vlib_buffer_t structure)   |
-----------------------------------------
| Packet Data Area                     |
-----------------------------------------

Important:

ğŸ‘‰ Metadata comes FIRST
ğŸ‘‰ Packet bytes come AFTER

Everything is in one continuous memory block.

ğŸ” Step 1: Metadata Section (Explained Visually)

Letâ€™s visualize it like indexed memory slots.

Buffer Memory Block
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ flags                                â”‚
â”‚ current_data                         â”‚
â”‚ current_length                       â”‚
â”‚ total_length_not_including_first...  â”‚
â”‚ next_buffer                          â”‚
â”‚ error                                â”‚
â”‚ sw_if_index[RX]                      â”‚
â”‚ sw_if_index[TX]                      â”‚
â”‚ feature_arc_index                    â”‚
â”‚ flow_id                              â”‚
â”‚ ... other internal fields ...        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ data[]  â† Packet starts here         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Now letâ€™s explain each one in simple terms.

ğŸ“Œ Metadata Fields Explained Like Memory Indexes

Imagine this is laid out sequentially in memory:

Index 0   â†’ flags
Index 1   â†’ current_data
Index 2   â†’ current_length
Index 3   â†’ total_length_not_including_first_buffer
Index 4   â†’ next_buffer
Index 5   â†’ error
Index 6   â†’ sw_if_index[RX]
Index 7   â†’ sw_if_index[TX]
Index 8   â†’ feature_arc_index
Index 9   â†’ flow_id
...
After that â†’ data[]

Now letâ€™s explain what each one stores.

ğŸ”¹ flags

Stores packet state.

Example bits:

Is traced?

Is checksum verified?

Is this buffer part of a chain?

It is like a packet status register.

ğŸ”¹ current_data (VERY IMPORTANT)

This tells:

Where does packet data currently start inside data[]

Example:

Suppose data area looks like:

[ Ethernet ][ IP ][ TCP ][ Payload ]

Initially:

current_data = 0

When Ethernet node finishes:

current_data = sizeof(Ethernet header)

Now IP header becomes the "current start".

ğŸ‘‰ No copying happens
ğŸ‘‰ Only pointer moves

Thatâ€™s why VPP is fast.

ğŸ”¹ current_length

Length of valid data in this buffer segment.

Example:

current_length = 1500 bytes

If packet is larger and split across buffers:

First buffer has part

Remaining is in next_buffer

ğŸ”¹ total_length_not_including_first_buffer

Used when packet spans multiple buffers.

If jumbo packet:

Buffer A â†’ next_buffer â†’ Buffer B â†’ Buffer C

This field tells how much data exists beyond first buffer.

ğŸ”¹ next_buffer

Stores index of next buffer in chain.

If no chaining:

next_buffer = 0

If chained:

next_buffer = buffer_index_of_next_piece
ğŸ”¹ error

If packet is dropped:

error = specific error code

Scheduler uses this for statistics.

ğŸ”¹ sw_if_index[2]

Stores interface info:

sw_if_index[0] â†’ RX interface
sw_if_index[1] â†’ TX interface

So routing nodes know:

Where packet came from

Where to send it

ğŸ”¹ feature_arc_index

Used in feature pipeline.

Example:

ACL

NAT

IPsec

Helps graph know which feature stage packet is in.

ğŸ§  Now the DATA[] Section

After metadata ends, packet memory begins.

Visually:

| Metadata |
|----------|
| data[0]  | â†’ First byte of allocated data area
| data[1]  |
| data[2]  |
| ...      |

But actual packet start is:

data + current_data

So real packet pointer is:

u8 *pkt = vlib_buffer_get_current(b);

Which equals:

b->data + b->current_data
ğŸ”¥ Full Visual Example

Letâ€™s say:

Packet size = 100 bytes

Ethernet header = 14 bytes

Initial state:

current_data = 0
current_length = 100

Memory:

data:
[ETH][IP][TCP][Payload]
 ^
 packet start

After Ethernet node:

current_data = 14

Now memory view:

data:
[ETH][IP][TCP][Payload]
       ^
       packet start now here

Nothing copied. Only offset moved.

ğŸš€ Why This Design Is Powerful

Instead of:

âŒ Removing headers by copying memory
VPP does:

âœ… Move current_data forward

That saves:

CPU cycles

Cache misses

Memory bandwidth

ğŸ” How Chaining Looks in Memory

If packet too large:

Buffer A:
  metadata
  data[ first 2048 bytes ]
  next_buffer = B

Buffer B:
  metadata
  data[ remaining bytes ]
  next_buffer = 0

So packet logically continues.

ğŸ¯ Compare With DPDK rte_mbuf

From DPDK

DPDK stores:

mbuf metadata
|
pointer to external data buffer

VPP stores:

metadata + data in same block

So VPP has better cache locality.

ğŸ§  Final Mental Model

Think of vlib_buffer_t like:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Packet Status Info           â”‚
â”‚ Routing Info                 â”‚
â”‚ Error Info                   â”‚
â”‚ Feature Info                 â”‚
â”‚ Pointer Offsets              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Actual Packet Bytes          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

And nodes donâ€™t modify packet memory directly.

They modify:

current_data
current_length
flags
ğŸ”¥ Important Insight

In VPP:

Frame â†’ buffer index â†’ vlib_buffer_t â†’ packet data

Graph never moves packets.
It only moves buffer indices.